# JVM
> ## java内村区域划分及内存溢出异常
>> ### 1.运行时数据区域
>>> 程序计数器
>>> java虚拟机栈
>>> 本地方法栈
>>> java堆
>>> 方法区
>>> 运行时常量池（方法区的一部分）
>>> 直接内存

>> ### 2.对象的创建
>>> new关键字时：先判断是否被初始化，没有则初始化类，加载
>>> 从堆为新生对象分配内存：2种分配方式:指针碰撞和空闲列表
		线程安全问题的处理（对分配动作进行同步处理，CAS+重试机制，每个线程在java堆中分配一小块内存）
>>> 初始化为零值
>>> 进行一些属性设置

>> ### 3.对象的内存布局
>>> 对象头：header
		1.对象运行时数据
		2.类型指针，及元数据指针
		3. 数组类型还有一个记录数组长度的数据
>>> 实例数据：Instance Data，实例代码中的各种类型子段的内容	
>>> 对齐填充：padding，字节必须时8的整数倍

>> ### 4.对象的访问定位
>>> 句柄
>>> 直接指针

>> ### 5.实战：OutOfMemoryError异常
>>> 1.java堆溢出
		  分析是否存在内存泻露，分析工具，查看GC引用链
		  存在，掌握了泄露对象的类型信息和GC root引用链信息就能定位代码的位置。
		  不存在，通过调整虚拟机堆大小的参数：
			 -Xmx 最大值
			 -Xms 最小值
>>> 2.虚拟机栈和本地方法区栈溢出
		  产生的情况
			  线程请求的栈深度超过虚拟机的最大深度，则抛出StackOverflowError
			  虚拟机在扩展栈时没有足够的内存，则抛出OutOfMemoryError
		  在单个线程下，无论是栈桢太大，还是虚拟机栈太小，当内存无法分配时，虚拟机抛出的都是stackOverflowError，如果不限于单线程，通过不断的创建新线程                 可以产生StackOverFlowError
>>> 3.方法区和运行时常量池溢出
		String.intern()方法在1.6和1.7以及后面的区别，1.7以后返回首次出现的地址
		方法区溢出常见问题
			动态语言，jdk动态代理和cglib时产生大量的方法
			大量JSP，或者产生大量JSP文件等
>>> 4.本机直接内存溢出：产生内存溢出时，一个明显的特征是heap dump文件不会太大，而程序中使用了NIO



		





