# JVM
> ## java内存区域划分及内存溢出异常
>> ### 1.运行时数据区域
1. 程序计数器
2. java虚拟机栈
3. 本地方法栈
4. java堆
5. 方法区
6. 运行时常量池（方法区的一部分）
7. 直接内存

>> ### 2.对象的创建
1. new关键字时：先判断是否被初始化，没有则初始化类，加载
2. 从堆为新生对象分配内存：2种分配方式:指针碰撞和空闲列表，线程安全问题的处理（对分配动作进行同步处理，CAS+重试机制，
每个线程在java堆中分配一小块内存）
3. 初始化为零值
4. 进行一些属性设置

>> ### 3.对象的内存布局
1. 对象头：header
		1）. 对象运行时数据
		2）. 类型指针，及元数据指针
		3）. 数组类型还有一个记录数组长度的数据
2. 实例数据：Instance Data，实例代码中的各种类型子段的内容	
3. 对齐填充：padding，字节必须时8的整数倍

>> ### 4.对象的访问定位
1. 句柄
2. 直接指针

>> ### 5.实战：OutOfMemoryError异常
1. java堆溢出:分析是否存在内存泻露，分析工具，查看GC引用链存在，掌握了泄露对象的类型信息和GC root引用链信息就能定位代码的位置。不存在，通过调整虚拟机堆大小的参数：-Xmx 最大值,-Xms 最小值
2. 虚拟机栈和本地方法区栈溢出,产生的情况:
>>> 1. 线程请求的栈深度超过虚拟机的最大深度，则抛出StackOverflowError,
>>> 2. 虚拟机在扩展栈时没有足够的内存，则抛出OutOfMemoryError
>>> 3. 在单个线程下，无论是栈桢太大，还是虚拟机栈太小，当内存无法分配时，虚拟机抛出的都是stackOverflowError，如果不限于单线程，通过不断的创建新线程可以产生StackOverFlowError
3. 方法区和运行时常量池溢出:String.intern()方法在1.6和1.7以及后面的区别，1.7以后返回首次出现的地址,方法区溢出常见问题:
>>> 1. 动态语言，jdk动态代理和cglib时产生大量的方法
>>> 2. 大量JSP，或者产生大量JSP文件等
4. 本机直接内存溢出：产生内存溢出时，一个明显的特征是heap dump文件不会太大，而程序中使用了NIO

> ## 垃圾收集器及内存分配策略
>> ### 1. 对象已死的判断：
>>> * 对象死亡的判断算法
>>>> 1. 引用计数法，基本思想：每个地方使用了，计数器加1，引用失效时计数器减1，计数器为0时则对象失效。缺点：无法解决循环引用的问题
>>>> 2. 可达性分析,基本思想：通过一系列的成为GC Roots的对象为起点，从这些节点向下搜索，搜索所走的路径成为引用链，当一个对象堆GC Roots没有任何引用链时则失效.java中GC Roots对象:
>>>>> * 虚拟机栈中引用的对象
>>>>> * 方法区中静态 属性引用的对象
>>>>> * 方法区中常量引用的对象
>>>>> * 本地方法中JNI引用的对象
>>> * 引用的分类
>>>> * 强：new的对象
>>>> * 软：SoftRefence
>>>> * 弱：WeakRefence
>>>> * 虚：PhantomRefence
>>> * finalize()方法的作用：对象自救，只能执行一次
>>> * 回收方法区，在大量使用动态代理的框架中需要回收方法区
>> ### 2. 垃圾回收算法
>>> 1. 标记清除算法
>>>> * 第一阶段标记要回收的对象，第二阶段回收
>>>> * 缺点：1.两阶段的效率都不高。2.回收后产生不连续的内存碎片。
>>>> * 优点：最简单的算法
>>> 2. 复制算法
>>>> * 将内存分成相同的2个部分，一部分用完之后，将存活的对象复制到另一部分上，在把使用过的内存空间全部清除。
>>>> * 优点：内存分配时不用考虑内存碎片，按顺序分配，实现简单，运行高效。
>>>> * 缺点：内存减少一般，代价太高，存活率高时效率低
>>>> * 应用：虚拟机用来回收新生代,将内存分为：1个Eden和2个Survivor，比例为8：1：1,每次使用eden和一个survivor，当回收时将eden和survivor中存活的对象复制到另一个survivor中，然后删除eden和survivor中的对象。当survivor的控制不够复制时，使用老年代的空间。
>>> 3. 标记-整理算法
>>>> * 标记过程与标记清除算法一样清除过程为让所有存活的对象向一端移动，然后清理端以外的内存。
>>>> * 应用：老年代回收算法
>>> 4. 分代收集算法
>>>> * 根据对象存活周期的不同，将内存划分为几块，将java堆分为新生代和老年代，然后使用不同的回收算法
>>>> * 应用：java堆的划分及回收算法
>> ### 3. Hotspot算法的实现
>>> * 枚举根结点
>>> * 安全点safepoint
>>> * 安全区域
>> ### 4. 垃圾收集器
>>> * Serial收集器
>>> * ParNew收集器
>>> * parallel scavenge收集器
>>> * serial old收集器
>>> * parallel old收集器
>>> * cms收集器
>>> * g1收集器
>>> * 理解gc日志
>>> * gc参数
>> ### 5. 内存分配和回收策略
>>> * 对象优先在Eden分配
>>>> * -Xmx：堆的最大值
>>>> * -Xms：堆的最小值
>>>> * -Xmn:新生代的大小
>>>> * -XX：SurvivorRatio=8 新生代中Eden和Survivor的比值
>>> * 大对象直接进入老年代：大对象是指，需要大量连续内存的对象，最典型的是那种很长的字符串以及数组。
>>>> * vm args：-XX：PretenureSizeThreshold = 1024 大于1024的对象直接分配到老年代
>>> * 长期存活的对象将进入老年代
>>>> * 虚拟机给每个对象定义了一个对象年龄（Age）计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且被Survivor容纳，将被移动到Survivor中，并且对象年龄设定为1.对象在Survivor中每熬过一次Minor GC，年龄加1，当年龄增大到一定程度（默认15），就会晋升到老年代。
>>>> * vm args：-XX：MaxTenuringThrrshold = 15 设置对象晋升到老年代的区域阀值
>>> * 动态对象年龄判断
>>>> * 定义：同年对象大小占Survivor空间大于一半时，年龄大于或等于该年龄的对象直接进入老年代。
>>> * 空间分配担保：
>>>> * 定义：在发生MInor GC时虚拟机会检查老年代的最大连续空间是否大于新生代所有对象的总和，如果条件成立，那么Minor GC是安全的；如果条件不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，如果允许，那么会检查老年代的最大连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试一次Minor GC；如果小于则进行Full GC
>>>> * vm args：-XX：-HandlePromotionFailure

> ## 虚拟机性能测试与故障处理工具
>> ### jdk的命令行工具
>>> 1. jps：虚拟机进程状况工具
>>> 2. jstat：虚拟机统计信息监视工具
>>> 3. jinfo：java配置信息工具
>>> 4. jmap：java内存映射工具
>>> 5. jhat：虚拟机堆转储快照分析工具
>>> 6. jstack：java堆栈分析工具
>>> 7. hsdis：jit生成代码反汇编
>> ### jdk的可视化工具
>>> 1. visualvm：多合一故障处理工具
>>> 2. jconsole：java监视与管理控制台

> ## 虚拟机类加载机制

>> ### 1. 概述
>>> 虚拟机把描述类的数据从class文件加载到内存中并对数据进行校验、转换、解析、和初始化的过程，最后生成可用的java类型的过程
	
>> ### 2. 类加载时机
	
	
>>> #### 1. 类从class加载到内存到卸载的生命周期
>>>> * 加载
>>>> * 连接
>>>>> * 验证
>>>>> * 准备
>>>>> * 解析
>>>> * 初始化
>>>> * 使用
>>>> * 卸载

>>> #### 2. 5种情况必须对类进行初始化
>>>> 1. 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类没有进行初始化，组需要先触发其初始化。对应的java场景：new实例化对象、读取一个类的静态字段、调用一个类的静态方法。
>>>> 2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发初始化。
>>>> 3. 初始化一个类时，其父类没有初始化，则触发初始化。
>>>> 4. 当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会先初始化这个类。
>>>> 5. 解析结果为指定的方法句柄，并且对应的类没有初始化，则需要触发其初始化。

>>> #### 3. 数组的初始化，不会引发类的初始化

>> ### 3. 类加载的过程
>>> * 加载
>>>> 1. 通过一个类名获取定义此类的二进制流
>>>> 2. 将这个类代表的静态存储结构转化为方法区的运行时数据结构
>>>> 3. 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口
>>> * 验证,4个阶段:
>>>> 1. 文件个时验证
>>>> 2. 元数据验证
>>>> 3. 字节码验证，stackMapTable
>>>> 4. 符号引用验证
>>>> * jvm args（关闭验证阶段）： -Xerify：none
>>> * 准备,准备阶段是正式为类变量（static修饰的变量）分配内存的并设置初始值的阶段，并在方法区中分配内存，初始值为数据类型的默认数值。final static修改的会直接赋值
>>> * 解析,解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程
>>> * 初始化,真正的开始执行类中定义的java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序指定的主观计划去初始化变量和其他资源，是执行类构造器<client>()方法的过程接口类也有<clinit>()方法，但不需要先执行父类的该方法。多线程情况初始化一个类时，只有一条线程执行clinit方法，虚拟机会同步
	
>> ### 4. 类加载器
>>> * 定义：对于任意一个类，都需要由加载它的类加载器和这个类本身来确立它在java虚拟机中的唯一性，每一个类加载器都有一个独立的类名称空间。
>>> * 双亲委派模型
>>>> 1. 分类
>>>>> 1. 启动类加载器
>>>>> 2. 扩展类加载器
>>>>> 3. 应用程序类加载器
>>>> 2. 双亲委派模型要求除了顶层的启动类加载器，其他每个类加载器都有其父类加载器。
>>>> 3. 工作过程：如果一个类加载器收到类加载的请求，他首先不会去尝试加载这个类，而是把请求委派给父类加载器去完成，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器无法加载时，子类加载器才会尝试去加载。
>>> * OSGI：动态部署

> ## 虚拟机字节码执行引擎

>> ### 运行时的栈桢结构
>>> * 局部变量表
>>>> * 不使用的对象应手动赋值为null
>>>> * 在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然会有一个确定的初始值。但是局部变量必须赋值
>>> * 操作数栈
>>> * 动态连接
>>> * 方法返回地址
>>> * 附加信息

>> ### 方法调用
>>> * 解析
>>> * 分派
>>> * 动态类型语言支持

>> ### 基于字节码解释执行引擎
>>> * 解释执行
>>> * 基于栈的指令集与基于寄存器的指令集
>>> * 基于栈的解释器执行过程







		





