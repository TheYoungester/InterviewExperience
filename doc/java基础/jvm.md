# JVM
> ## 1.java内存区域划分及内存溢出异常
>> ### 1.运行时数据区域
1. 程序计数器
2. java虚拟机栈
3. 本地方法栈
4. java堆
5. 方法区
6. 运行时常量池（方法区的一部分）
7. 直接内存

>> ### 2.对象的创建
1. new关键字时：先判断是否被初始化，没有则初始化类，加载
2. 从堆为新生对象分配内存：2种分配方式:指针碰撞和空闲列表，线程安全问题的处理（对分配动作进行同步处理，CAS+重试机制，
每个线程在java堆中分配一小块内存）
3. 初始化为零值
4. 进行一些属性设置

>> ### 3.对象的内存布局
1. 对象头：header
		1）. 对象运行时数据
		2）. 类型指针，及元数据指针
		3）. 数组类型还有一个记录数组长度的数据
2. 实例数据：Instance Data，实例代码中的各种类型子段的内容	
3. 对齐填充：padding，字节必须时8的整数倍

>> ### 4.对象的访问定位
1. 句柄
2. 直接指针

>> ### 5.实战：OutOfMemoryError异常
1. java堆溢出:分析是否存在内存泻露，分析工具，查看GC引用链存在，掌握了泄露对象的类型信息和GC root引用链信息就能定位代码的位置。不存在，通过调整虚拟机堆大小的参数：-Xmx 最大值,-Xms 最小值
2. 虚拟机栈和本地方法区栈溢出,产生的情况:
>>> 1. 线程请求的栈深度超过虚拟机的最大深度，则抛出StackOverflowError,
>>> 2. 虚拟机在扩展栈时没有足够的内存，则抛出OutOfMemoryError
>>> 3. 在单个线程下，无论是栈桢太大，还是虚拟机栈太小，当内存无法分配时，虚拟机抛出的都是stackOverflowError，如果不限于单线程，通过不断的创建新线程可以产生StackOverFlowError
3. 方法区和运行时常量池溢出:String.intern()方法在1.6和1.7以及后面的区别，1.7以后返回首次出现的地址,方法区溢出常见问题:
>>> 1. 动态语言，jdk动态代理和cglib时产生大量的方法
>>> 2. 大量JSP，或者产生大量JSP文件等
4. 本机直接内存溢出：产生内存溢出时，一个明显的特征是heap dump文件不会太大，而程序中使用了NIO

> ## 2. 垃圾收集器及内存分配策略
>> 1. 对象已死的判断：
>>> * 对象死亡的判断算法
>>>> 1. 引用计数法，基本思想：每个地方使用了，计数器加1，引用失效时计数器减1，计数器为0时则对象失效。缺点：无法解决循环引用的问题
>>>> 2. 可达性分析,基本思想：通过一系列的成为GC Roots的对象为起点，从这些节点向下搜索，搜索所走的路径成为引用链，当一个对象堆GC Roots没有任何引用链时则失效.java中GC Roots对象:
>>>>> * 虚拟机栈中引用的对象
>>>>> * 方法区中静态 属性引用的对象
>>>>> * 方法区中常量引用的对象
>>>>> * 本地方法中JNI引用的对象
>>> * 引用的分类
>>>> * 强：new的对象
>>>> * 软：SoftRefence
>>>> * 弱：WeakRefence
>>>> * 虚：PhantomRefence
>>> * finalize()方法的作用：对象自救，只能执行一次
>>> * 回收方法区，在大量使用动态代理的框架中需要回收方法区
>> 2. 垃圾回收算法
>>> 1. 标记清除算法
>>>> * 第一阶段标记要回收的对象，第二阶段回收
>>>> * 缺点：1.两阶段的效率都不高。2.回收后产生不连续的内存碎片。
>>>> * 优点：最简单的算法
>>> 2. 复制算法
>>>> * 将内存分成相同的2个部分，一部分用完之后，将存活的对象复制到另一部分上，在把使用过的内存空间全部清除。
>>>> * 优点：内存分配时不用考虑内存碎片，按顺序分配，实现简单，运行高效。
>>>> * 缺点：内存减少一般，代价太高，存活率高时效率低
>>>> * 应用：虚拟机用来回收新生代,将内存分为：1个Eden和2个Survivor，比例为8：1：1,每次使用eden和一个survivor，当回收时将eden和survivor中存活的对象复制到另一个survivor中，然后删除eden和survivor中的对象。当survivor的控制不够复制时，使用老年代的空间。
>>> 3. 标记-整理算法
>>>> * 标记过程与标记清除算法一样清除过程为让所有存活的对象向一端移动，然后清理端以外的内存。
>>>> * 应用：老年代回收算法
>>> 4. 分代收集算法
>>>> * 根据对象存活周期的不同，将内存划分为几块，将java堆分为新生代和老年代，然后使用不同的回收算法
>>>> * 应用：java堆的划分及回收算法
>> 3. Hotspot算法的实现
>>> * 枚举根结点
>>> * 安全点safepoint
>>> * 安全区域
>> 4. 垃圾收集器
>>> * Serial收集器
>>> * ParNew收集器
>>> * parallel scavenge收集器
>>> * serial old收集器
>>> * parallel old收集器
>>> * cms收集器
>>> * g1收集器
>>> * 理解gc日志
>>> * gc参数
>> 5. 内存分配和回收策略
>>> * 对象优先在Eden分配
>>>> * -Xmx：堆的最大值
>>>> * -Xms：堆的最小值
>>>> * -Xmn:新生代的大小
>>>> * -XX：SurvivorRatio=8 新生代中Eden和Survivor的比值
>>> * 大对象直接进入老年代：大对象是指，需要大量连续内存的对象，最典型的是那种很长的字符串以及数组。
>>>> * vm args：-XX：PretenureSizeThreshold = 1024 大于1024的对象直接分配到老年代
>>> * 长期存活的对象将进入老年代
>>>> * 虚拟机给每个对象定义了一个对象年龄（Age）计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且被Survivor容纳，将被移动到Survivor中，并且对象年龄设定为1.对象在Survivor中每熬过一次Minor GC，年龄加1，当年龄增大到一定程度（默认15），就会晋升到老年代。
>>>> * vm args：-XX：MaxTenuringThrrshold = 15 设置对象晋升到老年代的区域阀值
>>> * 动态对象年龄判断
>>>> * 定义：同年对象大小占Survivor空间大于一半时，年龄大于或等于该年龄的对象直接进入老年代。
>>> * 空间分配担保：
>>>> * 定义：在发生MInor GC时虚拟机会检查老年代的最大连续空间是否大于新生代所有对象的总和，如果条件成立，那么Minor GC是安全的；如果条件不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，如果允许，那么会检查老年代的最大连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试一次Minor GC；如果小于则进行Full GC
>>>> * vm args：-XX：-HandlePromotionFailure




		





